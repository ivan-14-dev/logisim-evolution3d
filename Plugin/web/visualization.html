<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <title>Logisim Evolution - Visualisation 3D</title>
    <style>
        body { margin: 0; overflow: hidden; background: #0a0a12; font-family: 'Segoe UI', sans-serif; }
        #container { width: 100vw; height: 100vh; }
        #controls {
            position: absolute; top: 20px; left: 20px;
            background: rgba(20, 20, 30, 0.9); padding: 15px;
            border-radius: 8px; color: white; border: 1px solid #334;
        }
        #controls h2 { margin: 0 0 10px 0; font-size: 16px; color: #4af; }
        .btn {
            background: #2a4a6a; border: none; padding: 8px 15px;
            color: white; cursor: pointer; border-radius: 4px; margin: 3px;
            transition: background 0.2s;
        }
        .btn:hover { background: #3a5a7a; }
        .btn.active { background: #4a6a9a; }
        #stats { position: absolute; bottom: 20px; left: 20px; color: #68a; font-size: 12px; }
        #legend {
            position: absolute; top: 20px; right: 20px;
            background: rgba(20, 20, 30, 0.9); padding: 15px;
            border-radius: 8px; color: white;
        }
        .legend-item { display: flex; align-items: center; margin: 5px 0; }
        .legend-color { width: 20px; height: 20px; border-radius: 50%; margin-right: 10px; }
    </style>
</head>
<body>
    <div id="container"></div>
    
    <div id="controls">
        <h2>Contr√¥les Cam√©ra</h2>
        <button class="btn active" onclick="setCameraMode('orbit')">Orbit</button>
        <button class="btn" onclick="setCameraMode('fps')">FPS</button>
        <button class="btn" onclick="setCameraMode('top')">Vue Haut</button>
        <button class="btn" onclick="resetCamera()">Reset</button>
        <hr style="border-color: #334;">
        <button class="btn" onclick="toggleSimulation()">‚ñ∂ Simuler</button>
        <button class="btn" onclick="randomizeStates()">üé≤ Al√©atoire</button>
    </div>
    
    <div id="legend">
        <h3 style="margin: 0 0 10px 0;">√âtats des Signaux</h3>
        <div class="legend-item">
            <div class="legend-color" style="background: #0f0;"></div>
            <span>HIGH (1)</span>
        </div>
        <div class="legend-item">
            <div class="legend-color" style="background: #444;"></div>
            <span>LOW (0)</span>
        </div>
        <div class="legend-item">
            <div class="legend-color" style="background: #f80;"></div>
            <span>FLOAT</span>
        </div>
        <div class="legend-item">
            <div class="legend-color" style="background: #f00;"></div>
            <span>ERROR</span>
        </div>
    </div>
    
    <div id="stats">
        Composants: <span id="compCount">0</span> | 
        FPS: <span id="fpsCount">60</span>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    
    <script>
        // === INITIALISATION THREE.JS ===
        let scene, camera, renderer, controls;
        let gates = [];
        let wires = [];
        let clock = new THREE.Clock();
        let simulationRunning = false;
        
        const COLORS = {
            HIGH: 0x00ff00,
            LOW: 0x444444,
            FLOAT: 0xff8800,
            ERROR: 0xff0000,
            PCB: 0x2a2a3a,
            WIRE: 0x00ccff
        };
        
        function init() {
            // Sc√®ne
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x0a0a12);
            scene.fog = new THREE.Fog(0x0a0a12, 50, 200);
            
            // Cam√©ra
            camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 30, 60);
            
            // Rendu
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            document.getElementById('container').appendChild(renderer.domElement);
            
            // Contr√¥les orbitaux
            controls = new THREE.OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.dampingFactor = 0.05;
            controls.minDistance = 10;
            controls.maxDistance = 200;
            
            // Lumi√®res
            setupLighting();
            
            // Cr√©er le circuit de d√©monstration
            createDemoCircuit();
            
            // Grid
            createGrid();
            
            // Event listeners
            window.addEventListener('resize', onWindowResize);
            
            // D√©marrer animation
            animate();
        }
        
        function setupLighting() {
            // Lumi√®re ambiante
            const ambient = new THREE.AmbientLight(0x404050, 0.5);
            scene.add(ambient);
            
            // Lumi√®re principale
            const directional = new THREE.DirectionalLight(0xffffff, 0.8);
            directional.position.set(50, 100, 50);
            directional.castShadow = true;
            scene.add(directional);
            
            // Lumi√®res color√©es pour ambiance
            const point1 = new THREE.PointLight(0x4080ff, 0.3, 100);
            point1.position.set(-30, 20, 30);
            scene.add(point1);
            
            const point2 = new THREE.PointLight(0x8040ff, 0.3, 100);
            point2.position.set(30, 20, -30);
            scene.add(point2);
        }
        
        function createGrid() {
            // Grid principal
            const gridHelper = new THREE.GridHelper(100, 20, 0x334466, 0x222244);
            scene.add(gridHelper);
            
            // Sol
            const planeGeo = new THREE.PlaneGeometry(100, 100);
            const planeMat = new THREE.MeshStandardMaterial({ 
                color: 0x111122, 
                roughness: 0.9,
                metalness: 0.1
            });
            const plane = new THREE.Mesh(planeGeo, planeMat);
            plane.rotation.x = -Math.PI / 2;
            plane.position.y = -0.1;
            plane.receiveShadow = true;
            scene.add(plane);
        }
        
        function createDemoCircuit() {
            // === PORTE AND ===
            createGate('AND', -20, 0, 0, 2);
            
            // === PORTE OR ===
            createGate('OR', -5, 0, 0, 2);
            
            // === PORTE NOT ===
            createGate('NOT', 10, 0, 0, 1);
            
            // === PORTE NAND ===
            createGate('NAND', 10, 10, 0, 2);
            
            // === PORTE XOR ===
            createGate('XOR', -5, 10, 0, 2);
            
            // === PLUS DE PORTES ===
            for (let i = 0; i < 8; i++) {
                const x = -30 + (i % 4) * 12;
                const z = -20 + Math.floor(i / 4) * 15;
                const type = ['AND', 'OR', 'NAND', 'XOR'][i % 4];
                createGate(type, x, z, 0, 2);
            }
            
            // === CABLES ===
            createWire(-14, 0, 0, -11, 0, 0);
            createWire(-1, 0, 0, 4, 0, 0);
            createWire(14, 0, 0, 18, 0, 0);
            createWire(-20, 10, 0, -20, 10, 0); // Demo wire
            
            document.getElementById('compCount').textContent = gates.length;
        }
        
        function createGate(type, x, z, y = 0, inputs = 2) {
            // Groupe pour la porte
            const gateGroup = new THREE.Group();
            gateGroup.position.set(x, y, z);
            
            let geometry, color;
            
            // Forme selon le type
            switch(type) {
                case 'AND':
                    geometry = new THREE.BoxGeometry(4, 2, 1);
                    color = COLORS.PCB;
                    break;
                case 'OR':
                    geometry = new THREE.CylinderGeometry(1.5, 1.5, 1, 32);
                    color = COLORS.PCB;
                    break;
                case 'NOT':
                    geometry = new THREE.ConeGeometry(1, 2, 4);
                    color = COLORS.PCB;
                    break;
                case 'NAND':
                    geometry = new THREE.BoxGeometry(4, 2, 1);
                    color = COLORS.PCB;
                    break;
                case 'XOR':
                    geometry = new THREE.TorusGeometry(1.2, 0.3, 8, 32);
                    color = COLORS.PCB;
                    break;
                default:
                    geometry = new THREE.BoxGeometry(3, 2, 1);
                    color = COLORS.PCB;
            }
            
            // Mat√©riau du –∫–æ—Ä–ø—É—Å–∞
            const material = new THREE.MeshStandardMaterial({
                color: color,
                roughness: 0.5,
                metalness: 0.3
            });
            const gateMesh = new THREE.Mesh(geometry, material);
            gateMesh.castShadow = true;
            gateGroup.add(gateMesh);
            
            // LED de sortie
            const ledGeo = new THREE.SphereGeometry(0.3, 16, 16);
            const ledMat = new THREE.MeshStandardMaterial({
                color: COLORS.LOW,
                emissive: COLORS.LOW,
                emissiveIntensity: 0.3
            });
            const led = new THREE.Mesh(ledGeo, ledMat);
            led.position.set(2.5, 0, 0);
            gateGroup.add(led);
            
            // Ports d'entr√©e (cercles)
            for (let i = 0; i < inputs; i++) {
                const portGeo = new THREE.CircleGeometry(0.2, 16);
                const portMat = new THREE.MeshBasicMaterial({ color: 0x886633 });
                const port = new THREE.Mesh(portGeo, portMat);
                port.position.set(-2.2, (i - (inputs-1)/2) * 0.8, 0.51);
                gateGroup.add(port);
            }
            
            // Texte du type
            // (simplifi√© - sans texte pour l'instant)
            
            scene.add(gateGroup);
            
            gates.push({
                mesh: gateGroup,
                led: led,
                type: type,
                state: Math.random() > 0.5 ? 'HIGH' : 'LOW',
                x: x,
                z: z
            });
            
            // Appliquer l'√©tat initial
            updateGateState(gates[gates.length - 1]);
        }
        
        function createWire(x1, z1, x2, z2) {
            const points = [];
            points.push(new THREE.Vector3(x1, 0.5, z1));
            
            // Cheminement simple (droit)
            const midX = (x1 + x2) / 2;
            points.push(new THREE.Vector3(midX, 0.5, z1));
            points.push(new THREE.Vector3(midX, 0.5, z2));
            points.push(new THREE.Vector3(x2, 0.5, z2));
            
            const geometry = new THREE.BufferGeometry().setFromPoints(points);
            const material = new THREE.LineBasicMaterial({ 
                color: COLORS.WIRE,
                linewidth: 2
            });
            
            const wire = new THREE.Line(geometry, material);
            scene.add(wire);
            
            wires.push({
                mesh: wire,
                state: Math.random() > 0.5 ? 'HIGH' : 'LOW'
            });
        }
        
        function updateGateState(gate) {
            const color = COLORS[gate.state];
            gate.led.material.color.setHex(color);
            gate.led.material.emissive.setHex(color);
            gate.led.material.emissiveIntensity = gate.state === 'HIGH' ? 1 : 0.2;
        }
        
        function randomizeStates() {
            gates.forEach(gate => {
                const states = ['HIGH', 'LOW', 'FLOAT'];
                gate.state = states[Math.floor(Math.random() * states.length)];
                updateGateState(gate);
            });
            
            wires.forEach(wire => {
                wire.state = Math.random() > 0.5 ? 'HIGH' : 'LOW';
                wire.mesh.material.color.setHex(wire.state === 'HIGH' ? COLORS.WIRE : COLORS.LOW);
            });
        }
        
        function toggleSimulation() {
            simulationRunning = !simulationRunning;
            if (simulationRunning) {
                setInterval(() => {
                    if (simulationRunning) randomizeStates();
                }, 500);
            }
        }
        
        function setCameraMode(mode) {
            document.querySelectorAll('.btn').forEach(b => b.classList.remove('active'));
            event.target.classList.add('active');
            
            switch(mode) {
                case 'orbit':
                    controls.enabled = true;
                    break;
                case 'fps':
                    camera.position.set(0, 5, 0);
                    camera.lookAt(0, 0, -10);
                    break;
                case 'top':
                    camera.position.set(0, 80, 0);
                    camera.lookAt(0, 0, 0);
                    controls.enabled = false;
                    break;
            }
        }
        
        function resetCamera() {
            camera.position.set(0, 30, 60);
            camera.lookAt(0, 0, 0);
            controls.reset();
        }
        
        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }
        
        let frameCount = 0;
        let lastTime = performance.now();
        
        function animate() {
            requestAnimationFrame(animate);
            
            // FPS counter
            frameCount++;
            const now = performance.now();
            if (now - lastTime >= 1000) {
                document.getElementById('fpsCount').textContent = frameCount;
                frameCount = 0;
                lastTime = now;
            }
            
            controls.update();
            renderer.render(scene, camera);
        }
        
        // D√©marrer
        init();
    </script>
</body>
</html>
